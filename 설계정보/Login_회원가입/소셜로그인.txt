소셜로그인 구현

1. 전체 구현 단계 
	0) 준비 (환경)
		Spring Boot 3.x + Spring Security (OAuth2 client) 사용
		Java 17 이상 권장
		Dependency: spring-boot-starter-oauth2-client
		
	1) 각 소셜(카카오/네이버/구글) 개발자 콘솔에 앱 등록
		- Client ID / Client Secret 발급, 리다이렉트 URI 등록(정확히 일치해야 함). 로컬 개발은 http://localhost:... 또는 ngrok 같은 HTTPS 터널 사용. 
		- 등록 시 요구되는 정보(앱 이름, 서비스 URL, 개인정보 처리방침 URL 등)를 미리 준비
		- 로컬 테스트 시 HTTPS가 필요하면 ngrok으로 외부 HTTPS URL을 내부로 포워딩 가능
	
	2) 시크릿 관리 (절대 코드/레포에 커밋 금지)
		- CLIENT_ID, CLIENT_SECRET을 주입
	
	3) Spring 설정 (application.yml) — provider 등록
		- Google은 Spring에 기본 제공(또는 표준 OIDC)이라 설정이 간단
		- Kakao, Naver는 사용자정보 구조가 다르므로 provider 항목을 직접 추가해 custom provider로 등록해야 함
	
	<application.yml> - 예시
	spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            scope: openid, profile, email

          kakao:
            client-id: ${KAKAO_CLIENT_ID}
            client-secret: ${KAKAO_CLIENT_SECRET}
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/kakao"
            scope: profile, account_email

        provider:
          kakao:
            authorization-uri: https://kauth.kakao.com/oauth/authorize
            token-uri: https://kauth.kakao.com/oauth/token
            user-info-uri: https://kapi.kakao.com/v2/user/me
            user-name-attribute: id

          naver:
            authorization-uri: https://nid.naver.com/oauth2.0/authorize
            token-uri: https://nid.naver.com/oauth2.0/token
            user-info-uri: https://openapi.naver.com/v1/nid/me
            user-name-attribute: response.id

		- Spring의 OAuth2 auto-config 와 기본 엔드포인트(/oauth2/authorization/{registrationId},
			콜백 /login/oauth2/code/{registrationId})을 활용하면 
			프론트는 로그인 버튼 클릭으로 서버의 /oauth2/authorization/kakao로 리다이렉트 가능
		
	4) OAuth 콜백 → 사용자 정보 처리 (핵심)
		- **Spring Security의 OAuth2UserService**를 커스터마이징해서 provider 별로 
			(Kakao/ Naver의 nested JSON 등) 이메일/이름/고유ID 를 추출해 **내 DB 사용자(User)**로 생성하거나 연결(link)합니다.
		
		- 전체 흐름
			ㄱ. Provider 인증 → 
			ㄴ. 백엔드 code 교환 → 
			ㄷ. access token → 
			ㄹ. user-info 호출 → 
			ㅁ. OAuth2User 생성 → 
			ㅂ. DB에서 사용자 찾기(없으면 생성) → 
			ㅅ. Spring Security 인증 컨텍스트에 넣기

		주의: Kakao/Naver는 이메일이 없을 수 있으니(사용자 동의 여부) 이메일 없는 경우의 처리(임시ID, 추가 입력 유도)를 반드시 설계. 
				(provider별 user-info 구조는 문서 참고).
				
	
	5) 가입(신규) vs 로그인(기존) 로직 설계
		- DB 컬럼 1차: users(id, email, name, provider, provider_id, roles, created_at, last_login, provider_refresh_token_encrypted)
		- 같은 이메일이면 social 계정 연결, 아니면 새 계정 생성. (복수 provider 연결 기능은 추후 고려)
	
	6) 세션 / 토큰 전략 (중요)
		- 기본: Spring Security 기본 session-cookie 방식(서버 세션)
				간단, 상태 저장(서버). CSRF/Cookie 기본 보호 필요.
		- 도전과제: JWT 기반 무상태(stateless) 인증(API 토큰 + refresh token)으로 전환
				프론트-백 분리된 SPA API에 적합(토큰 저장/재발급/탈취 위험 설계 필요)
	
	7) 로그아웃 / 토큰 폐기
		- OAuth access/refresh token을 저장했다면 (옵션) 로그아웃 시 provider에 토큰 폐기 API 호출을 고려할 수 있음.
		- 로컬 세션 삭제 + 쿠키 만료 처리 필요
		
	8) 보안/운영 체크리스트 (꼭)
		- 리다이렉트 URI는 정확히 일치해야 함(포트, 스킴 포함)
		- 클라이언트 시크릿은 절대 깃에 커밋 금지(Env/Jenkins/Vault)
		- 로그에 시크릿/토큰 절대 찍지 않기 (운영 환경에서는!)
		- 사용자 동의(scope)와 개인정보 처리 고지 확인 (운영에서!)
		
	9) 테스트 방법
		- Provider별로 독립적으로 테스트 (Google 먼저 → Kakao → Naver)
		- 로컬 HTTPS: ngrok 이용 → 리다이렉트 URI에 ngrok 주소 등록 후 테스트 (흠... 로컬 HTTP 가능여부 확인 해봐야겠음)